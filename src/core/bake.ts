import path from "path";
import fs from "fs";
import fg from "fast-glob";
import esbuild from "esbuild";
import { type BakeResult, type BakedTemplateIndexEntry } from "./types";

export async function bakeTemplates(params: {
  templatesDir: string;
  outDir: string;
}): Promise<BakeResult> {
  const { templatesDir } = params;
  const outDir = path.resolve(params.outDir);
  fs.mkdirSync(outDir, { recursive: true });

  const templateFiles = await fg(["**/*.ts", "**/*.tsx"], {
    cwd: templatesDir,
    absolute: true,
  });
  // Continue even if no templates are present; produce an empty index
  const entries: BakedTemplateIndexEntry[] = [];
  const buildOutDir = path.join(outDir, "templates");
  fs.mkdirSync(buildOutDir, { recursive: true });

  await Promise.all(
    (templateFiles as string[]).map(async (absPath: string) => {
      const rel = path.relative(templatesDir, absPath);
      const id = path.basename(rel, path.extname(rel));
      const outfile = path.join(buildOutDir, `${id}.js`);
      await esbuild.build({
        entryPoints: [absPath],
        outfile,
        bundle: true,
        platform: "node",
        target: ["node20"],
        format: "cjs",
        sourcemap: false,
        logLevel: "silent",
      });
      entries.push({ id, path: `templates/${id}.js` });
    })
  );

  const indexFile = path.join(outDir, "templates.index.cjs");
  const lines = [
    "// Auto-generated by transflow bake",
    "module.exports = {",
    ...entries.map(
      (e) =>
        `  ${JSON.stringify(e.id)}: require('./${e.path.replace(/\\/g, "/")}'),`
    ),
    "};\n",
  ];
  fs.writeFileSync(indexFile, lines.join("\n"));

  // Copy Dockerfile asset into build context (prefer package assets)
  const pkgDockerfile = path.resolve(__dirname, "../../assets/Dockerfile");
  const cwdDockerfile = path.resolve(process.cwd(), "assets/Dockerfile");
  const dockerfileSrc = fs.existsSync(pkgDockerfile)
    ? pkgDockerfile
    : fs.existsSync(cwdDockerfile)
    ? cwdDockerfile
    : undefined;
  if (dockerfileSrc) {
    fs.copyFileSync(dockerfileSrc, path.join(outDir, "Dockerfile"));
  }

  // Emit minimal package.json for runtime install
  const runtimePkg = {
    name: "transflow-lambda",
    private: true,
    version: "0.0.0",
    main: "dist/lambda/handler.js",
    dependencies: {
      "@aws-sdk/client-s3": "^3.645.0",
      "@aws-sdk/client-dynamodb": "^3.645.0",
      "@aws-sdk/lib-dynamodb": "^3.645.0",
      ioredis: "^5.4.1",
    },
  } as const;
  fs.writeFileSync(
    path.join(outDir, "package.json"),
    JSON.stringify(runtimePkg, null, 2)
  );

  // Compile/copy handlers into build context
  const distDir = path.join(outDir, "dist/lambda");
  fs.mkdirSync(distDir, { recursive: true });

  // Prefer compiled JS from the installed package; fallback to building from TS when running from repo
  const pkgRootDist = path.resolve(__dirname, "../"); // dist/core â†’ dist
  const candidateCompiledHandler = path.join(pkgRootDist, "lambda/handler.js");
  const candidateCompiledStatus = path.join(
    pkgRootDist,
    "lambda/statusHandler.js"
  );
  const repoTsHandler = path.resolve(process.cwd(), "src/lambda/handler.ts");
  const repoTsStatus = path.resolve(
    process.cwd(),
    "src/lambda/statusHandler.ts"
  );

  async function ensureFile(srcJs: string, srcTs: string, outJs: string) {
    if (fs.existsSync(srcJs)) {
      fs.copyFileSync(srcJs, outJs);
      return;
    }
    await esbuild.build({
      entryPoints: [srcTs],
      outfile: outJs,
      bundle: true,
      platform: "node",
      target: ["node20"],
      format: "cjs",
      sourcemap: false,
      logLevel: "silent",
      external: ["ioredis", "@aws-sdk/*"],
    });
  }

  await ensureFile(
    candidateCompiledHandler,
    repoTsHandler,
    path.join(distDir, "handler.js")
  );
  await ensureFile(
    candidateCompiledStatus,
    repoTsStatus,
    path.join(distDir, "statusHandler.js")
  );

  return { outDir, entries, indexFile };
}
